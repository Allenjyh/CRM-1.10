<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title>发布公告</title>
		<meta name="viewport" content="width=device-width, initial-scale=1,maximum-scale=1, user-scalable=no">
		<meta name="apple-mobile-web-app-capable" content="yes">
		<meta name="apple-mobile-web-app-status-bar-style" content="black">
		<script src="js/jquery-3.3.1.min.js"></script>
		<style type="text/css">
		* {
				box-sizing: border-box;
				font-size: 13px;
				margin: 0;
				padding: 0;
			}
			a {
				text-decoration: none;
				color: rgba(0,0,0,0.65);
			}
			ul, ol, li {
				list-style: none;
			}
			ul, ol, li {
				padding: 0;
				margin: 0;
				list-style: none;
			}
			input, span {
				border: none;
				outline: none;
			}
			body {
				margin: 0;
				padding: 0;
				background: #F5F5F5;
				font-family: PingFang-SC-Regular;
			}
			/* 省略号 */
			.onehide{
				text-overflow: ellipsis;/*不显示的地方用省略号...代替*/
				white-space:nowrap;
				overflow: hidden;
			}
			.threehide{
				text-overflow: -o-ellipsis-lastline;
				overflow: hidden;
				text-overflow: ellipsis;
				display: -webkit-box;
				-webkit-line-clamp: 3;
				line-clamp: 3;
				-webkit-box-orient: vertical;
			}
			/* 滚动条 */
			 .roomLevel3-ul {
				width: 100vw;
				margin: 0 auto;
				max-height: calc(100vh - 97px);
				overflow-y: auto;
			}
			.roomLevel3-ul::-webkit-scrollbar {
				width: 4px;
				height: 1px;
			}
			.roomLevel3-ul::-webkit-scrollbar-thumb {
				border-radius: 4px;
				-webkit-box-shadow: inset 0 0 5px rgba(0, 0, 0, 0.2);
				background: rgba(24, 189, 247, 1);
			}
			.roomLevel3-ul::-webkit-scrollbar-track {
				-webkit-box-shadow: inset 0 0 5px rgba(0, 0, 0, 0.2);
				border-radius: 4px;
				background: #CBE5F9;
			}
			.addParkName-btn {
				background: linear-gradient(180deg, rgba(24, 189, 247, 1) 0%, rgba(10, 136, 236, 1) 100%);
				width: calc(100vw * 0.893);
				height: 54px;
				margin: 20px auto 0 auto;
				text-align: center;
				color: #FFFFFF;
				line-height: 54px;
				font-size: 20px;
				left: calc(100vw * 0.107 / 2);
				bottom: 31px;
				position: fixed;
			}
			.roomLevel3-ul table {
				margin: 0;
				padding: 0;
				width: calc(100vw - 24px)!important;
				margin: 0 auto;
				background: #FFFFFF;
			}
			.roomLevel3-ul table tr td {
				position: relative;
				padding: 12px  10px;
				font-size:15px;
				color:rgba(0,0,0,0.45);
			}
			.roomLevel3-ul table tr td p:first-of-type{
				margin: 0 0 10px 0;
				font-family: PingFang-SC-Medium;
				font-size: 13px;
				color: rgba(0,0,0,0.85);
				height: 22px;
				line-height: 22px;
				width: calc(100vw - 110px);
			}
			.roomLevel3-ul table tr td p:last-of-type{
				 margin: 0;
				width: calc(100vw - 60px);
			}
			.roomLevel3-ul table tr td span.delete{
			   position: absolute;
			   right: 10px;
			   top: 14px;
			}
		</style>
	</head>
	<body>
		<div class="roomLevel3-ul">
			<div style="width: 100%; height: 10px;background: #F3F3F3;"></div>
			 <label>
				 <table >
						<tr >
							<td >
								<p class="onehide"> 广贸商务中心东</p>
								<span class="delete" onclick="_delete(this)">删除</span>
								<p class="threehide"> 中国广东省广州市好多中国广东省广州市好多中国广广东省广州市好多中国广东省广州市好多中国广东省广州市好多中国广东省广州市好多广东省广州市好多中国广东省广州市好</p>							
							</td>
						</tr>
						<tr>
						</tr>
					</tbody>
				</table>
			</label>
			<div style="width: 100%; height: 10px;background: #F3F3F3;"></div>
			 <label>
				 <table >
						<tr >
							<td >
								<p class="onehide"> 广贸商务中心东省好多中国广东省广 市</p>
								<span class="delete" onclick="_delete(this)">1删除</span>
								<p class="threehide"> 市好多中国广东省广州市好多中国市好</p>
							</td>
						</tr>
						<tr>
						</tr>
					</tbody>
				</table>
			</label>
			<div style="width: 100%; height: 10px;background: #F3F3F3;"></div>
			 <label>
				 <table >
						<tr >
							<td >
								<p class="onehide"> 广贸商务中心东省好多中国广东省广 市</p>
								<span class="delete" onclick="_delete(this)">2删除</span>
								<p class="threehide"> 好多中国广东省广州市好多中国广东省广州市省广州市好多中国广东省广州市好</p>
							</td>
						</tr>
						<tr>
						</tr>
					</tbody>
				</table>
			</label>
			<div style="width: 100%; height: 10px;background: #F3F3F3;"></div>	
		</div>
		<div class="addParkName-btn">
			发 布
		</div>
	</body>
<script>
	$(".delete").click(function(){
        //   alert(2)
	})
	function _delete(that){
		alert($(that).text())
	}

	// 1、工厂模式

	function createPerson(name, job) { 
		var o = new Object()
		o.name = name
		o.job = job
		o.sayName = function() {    
			console.log(this.name)
		} 
		return o
		}
		// var person1 = createPerson('Jiang', 'student');
		// var person2 = createPerson('X', 'Doctor');

	// 可以无数次调用这个工厂函数，每次都会返回一个包含两个属性和一个方法的对象
	// 工厂模式虽然解决了创建多个相似对象的问题，但是没有解决对象识别问题，即不能知道一个对象的类型
		// console.log(person1)	
		// console.log(person2)//{name: "Jiang", job: "student", sayName: ƒ}


	// 2、构造函数模式
	function Person(name, job) {  
		this.name = name  ;
		this.job = job  ;
		this.sayName = function() {    
			console.log(this.name);
		}
	}
	// var person1 = new Person('Jiang', 'student');
	// var person2 = new Person('X', 'Doctor');

	// console.log(person1)	// Person {name: "X", job: "Doctor", sayName: ƒ}
	// console.log(person2)


	// 没有显示的创建对象，使用new来调用这个构造函数，使用new后会自动执行如下操作
	// 创建一个新对象
	// 这个新对象会被执行[[prototype]]链接
	// 这个新对象会绑定到函数调用的this
	// 返回这个对象
	// 使用这个方式创建对象可以检测对象类型

	// console.log(person1 instanceof Object )// true
	// console.log(person1 instanceof Person) //true
	// 但是使用构造函数创建对象，每个方法都要在每个实例上重新创建一次

// 	3、原型模式

function Person() {
}
Person.prototype.name = 'Jiang';
Person.prototype.job = 'student';
Person.prototype.sayName = function() {  console.log(this.name);
}
// var person1 = new Person();
// console.log(person1)
// 将信息直接添加到原型对象上。使用原型的好处是可以让所有的实例对象共享它所包含的属性和方法，不必在构造函数中定义对象实例信息。

// 原型是一个非常重要的概念，在一篇文章看懂proto和prototype的关系及区别中讲的非常详细

// 更简单的写法

// function Person() {
// }
// Person.prototype = {
//   name: 'jiang',
//   job: 'student',
//   sayName: function() {    console.log(this.name)
//   }
// }var person1 = new Person()
// 将Person.prototype设置为等于一个以对象字面量形式创建的对象，但是会导致.constructor不在指向Person了。

// 使用这种方式，完全重写了默认的Person.prototype对象，因此 .constructor也不会存在这里

// Person.prototype.constructor === Person  // false
// 如果需要这个属性的话，可以手动添加

// function Person() {
// }
// Person.prototype = {
//   constructor：Person
//   name: 'jiang',
//   job: 'student',
//   sayName: function() {
//     console.log(this.name)
//   }
// }
// 不过这种方式还是不够好，应为constructor属性默认是不可枚举的，这样直接设置，它将是可枚举的。所以可以时候，Object.defineProperty方法

// Object.defineProperty(Person.prototype, 'constructor', {
//   enumerable: false,
//   value: Person
// })
// 缺点

// 使用原型，所有的属性都将被共享，这是个很大的优点，同样会带来一些缺点

// 原型中所有属性实例是被很多实例共享的，这种共享对于函数非常合适。对于那些包含基本值的属性也勉强可以，毕竟实例属性可以屏蔽原型属性。但是引用类型值，就会出现问题了

function Person() {
}
Person.prototype = {
  name: 'jiang',
  friends: ['Shelby', 'Court']
}
// var person1 = new Person();
// var person2 = new Person();
// person1.friends.push('Van');
// console.log(person1.friends); //["Shelby", "Court", "Van"]
// console.log(person2.friends); //["Shelby", "Court", "Van"]
// console.log(person1.friends === person2.friends); // true
// friends存在与原型中，实例person1和person2指向同一个原型，person1修改了引用的数组，也会反应到实例person2中

// 4、组合使用构造函数模式和原型模式

// 这是使用最为广泛、认同度最高的一种创建自定义类型的方法。它可以解决上面那些模式的缺点

// 使用此模式可以让每个实例都会有自己的一份实例属性副本，但同时又共享着对方法的引用

// 这样的话，即使实例属性修改引用类型的值，也不会影响其他实例的属性值了

function Person(name) {  
	this.name = name  
	this.friends = ['Shelby', 'Court']
}
// Person.prototype.sayName = function() {  console.log(this.name)
// }
// var person1 = new Person()
// var person2 = new Person()
// person1.friends.push('Van')
// console.log(person1.friends)  //["Shelby", "Court", "Van"]
// console.log(person2.friends) // ["Shelby", "Court"]
// console.log(person1.friends === person2.friends) //false

// 5、动态原型模式

// 动态原型模式将所有信息都封装在了构造函数中，初始化的时候，通过检测某个应该存在的方法时候有效，来决定是否需要初始化原型
function Person(name, job) {  // 属性
  this.name = name;  
  this.job = job ; // 方法
  if(typeof this.sayName !== 'function') {
    // Person.prototype.sayName = function() {       console.log(this.name) }
  }

}
// var person1 = new Person('Jiang', 'Student')
// person1.sayName()
// 只有在sayName方法不存在的时候，才会将它添加到原型中。这段代码只会初次调用构造函数的时候才会执行。

// 此后原型已经完成初始化，不需要在做什么修改了

// 这里对原型所做的修改，能够立即在所有实例中得到反映

// 其次，if语句检查的可以是初始化之后应该存在的任何属性或方法，所以不必用一大堆的if语句检查每一个属性和方法，只要检查一个就行

// 6、寄生构造函数模式

// 这种模式的基本思想就是创建一个函数，该函数的作用仅仅是封装创建对象的代码，然后再返回新建的对象

function Person(name, job) {  
  var o = new Object();
  o.name = name;
  o.job = job;
  o.sayName = function() {    console.log(this.name)
  }  
  return o
}
// var person1 = new Person('Jiang', 'student');
// person1.sayName();
// 这个模式，除了使用new操作符并把使用的包装函数叫做构造函数之外，和工厂模式几乎一样

// 构造函数如果不返回对象，默认也会返回一个新的对象，通过在构造函数的末尾添加一个return语句，可以重写调用构造函数时返回的值

// 7、稳妥构造函数模式

// 首先明白稳妥对象指的是没有公共属性，而且其方法也不引用this。

// 稳妥对象最适合在一些安全环境中（这些环境会禁止使用this和new），或防止数据被其他应用程序改动时使用

// 稳妥构造函数模式和寄生模式类似，有两点不同:一是创建对象的实例方法不引用this，而是不使用new操作符调用构造函数

function Person(name, job) { 
  var o = new Object()
  o.name = name
  o.job = job
  o.sayName = function() {    console.log(name)
  } 
   return o
}
var person1 = Person('Jiang', 'student')
person1.sayName()
// 和寄生构造函数模式一样，这样创建出来的对象与构造函数之间没有什么关系，instanceof操作符对他们没有意义。
</script>
</html>